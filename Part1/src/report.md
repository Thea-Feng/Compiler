# CSC4180 Assignment 1 Report
## Name: Yutong Feng ID: 120090266
- Excution
    - Compile the source code with the command "make all"
    - Example: test0.m
    ```bash
    120090266@c2d52c9b1339:~/CSC4180-Compiler/Assignment1$ make all
    120090266@c2d52c9b1339:~/CSC4180-Compiler/Assignment1$ ./compiler ./testcases/test0.m
    export parse tree filename: ast.dot
    120090266@c2d52c9b1339:~/CSC4180-Compiler/Assignment1$ dot -Tpng ./ast.dot -o ./ast.png
    120090266@c2d52c9b1339:~/CSC4180-Compiler/Assignment1$ opt ./program.ll -S --O3 -o ./program_optimized.ll
    120090266@c2d52c9b1339:~/CSC4180-Compiler/Assignment1$ llc -march=riscv64 ./program_optimized.ll -o ./program.s
    120090266@c2d52c9b1339:~/CSC4180-Compiler/Assignment1$ riscv64-unknown-linux-gnu-gcc ./program.s -o ./program
    120090266@c2d52c9b1339:~/CSC4180-Compiler/Assignment1$ qemu-riscv64 -L /opt/riscv/sysroot ./program
    30
    ```
    - You can also use "verify_compiler.sh" for multiple testcases. The ast, cst and output will be the same as your provided answers while llvm_ir will have some slight differences due to different design.

- Scanner
    - Scanner can recognize tokens of MICRO expressed as RegEx. Some special cases include *[a-zA-Z][a-zA-Z0-9]{0,31}* for ID and *[0-9]+* for INTLITERAL. Under "scan_only" mode, scanner will only print the token type. Otherwise, it will build a SynaxtTree node by using *yylval.ptr* which is a Node pointer. Value of ID and INTLITERAL will be passed from *yytext*.
    - Special cases: for negative INTLITERAL, it should be defined as *-?[0-9]*. However, to consider cases such as *write(2-3)* with the rule of matching the longest, we should leave parser to deal with the minus (such as: PRIMARY: INTLITERAL | MINUSOP INTLITERAL).

- Parser
    - The implementation of parser is translating the extended CFG of Micro Language:
    ```js
        1. <program> → BEGIN <statement list> END
        2. <statement list> → <statement> {<statement>}
        3. <statement> → ID ASSIGNOP <expression>;
        4. <statement> → READ LPAREN <id list> RPAREN;
        5. <statement> → WRITE LPAREN<expr list> RPAREN;
        6. <id list > → ID {COMMA ID}
        7. <expr list > → <expression> {COMMA <expression>} 
        8. <expression> → <primary> {<add op> <primary>}
        9. <primary> → LPAREN <expression> RPAREN
        10. <primary> → ID
        11. <primary> → INTLITERAL
        12. <add op> → PLUOP
        13. <add op> → MINUSOP
        14. <system goal> → <program> SCANEOF
    ```
    - For the grammar with extended notation like `{<id list>}, <expr list >, <statement list>, <expression>`, it needs some modifications. For example, I `ID_LIST: ID | ID COMMA ID_LIST`.
    - For CST, we need to create a ST node for every non-terminal symbols (terminal nodes are built in scanner). For AST, we only need to create a ST node for `<program>, <statement list>, READ` and `WRITE`.
    
- Intermediate Code Generator
    - IR is generated by LLVM. The main idea is to generate strings due to simplicity of micro language. `IR_Generator` takes the AST generated from parser and generate LLVM IR instructions. It calls `gen_llvm_ir` recursively to generate LLVM IR instruction for each node in the AST. 
    - `map` in STL is used to allocate ID and registers return results (`string) of functions (*cost little memory compared to be stored in array of map; save spaces when encoutering large calculation*).
    - For ID, we call `alocVariable(std::string id)` to allocate address.
    - For READ, we call `genRead(Node *node)` to generate read code. We need to allocate each child (ID) of READ node first.
    - For WRITE, we call `genWrite(Node *node, std::vector<std::string>)` to generate write code. We need to load value of each child (EXPRESSION) of WRITE node from memory to register first. Name of registers are stored in the second parameter vector.
    - For MINUSOP/PLUSOP, we call `add/sub(std::string lf, std::string rg)`, it will return the register which stores the result.
    - FOR ASSIGNOP, we call `storeReg(std::string addr, std::string rg)` to store the value from register to memory.

- Bonus
    - Parser/Scanner will also print the error message if it encounters an error and gives the location of error by using `yylineno`.